# 基础篇：JVM运行时内存布局

JVM运行时内存布局如下：
![image](https://user-images.githubusercontent.com/13992911/115152364-5ddfe600-a0a3-11eb-9c90-a805dfa14cb0.png)

其中，Java虚拟机栈、程序计数器、Heap、本地方法栈、Metaspace属于JVM运行时的内存；

JAVA堆和MetasSpace元空间属于线程共享的（黄色部分）；虚拟机栈和本地方法栈、程序计数器是线程私有的

**虚拟机栈和本地方法栈、程序计数器 3个区域，生命周期与Thread相同，即：线程创建时，相应的内存区创建，线程销毁时，释放相应内存。**

## 1、JVM的内存区域布局
* java代码的执行步骤有三点
   * java源码文件->编译器->字节码文件
   * 字节码文件->JVM->机器码
   * 机器码->系统CPU执行
* JVM执行的字节码需要用类加载来载入；字节码文件可以来自本地文件，可以在网络上获取，也可以实时生成。就是说你可以跳过写java代码阶段，直接生成字节码交由JVM执行
* 其中Java虚拟机栈、程序计数器、Heap、本地方法栈、Metaspace属于JVM运行时的内存；

### 2.1 程序计数器（Progarm Counter Register)
* 一块较小的内存空间, 是当前线程所执行的字节码的行号指示器。线程有一个独属的程序计数器，字节码解析工作时需要程序计数器来选取下一指令，分支、循环、跳转等依赖它
* 正在执行java方法线程的计数器记录的是虚拟机字节码指令的地址；如果还是Native方法，则为空
* 程序计数器内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError错误的区域

### 2.2 虚拟机栈(Virtual Machine Stack)
![image](https://user-images.githubusercontent.com/13992911/115152702-b368c280-a0a4-11eb-9f1f-89158bc4a593.png)

* Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息
* 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程
* 栈帧是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派(Dispatch Exception)。栈帧随着方法调用而创建，随着方法结束而销毁(无论方法是正常完成还是异常完成)
* 如果线程请求的栈深度大于虚拟机允许深度，则抛出StackOverflowError；扩展时无法申请到足够内存，则抛出OutOfMemeryError

### 2.3 本地方法栈(Native Method Stack)

本地方法栈和虚拟机栈作用类似，区别是虚拟机栈为执行Java方法服务，而本地方法栈则为Native方法服务。(HopShot的实现 直接把本地方法栈和虚拟机栈合二为一）

**上述3类区域，生命周期与Thread相同，即：线程创建时，相应的内存区创建，线程销毁时，释放相应内存。**

### 2.4 堆(Heap)
线程共享的一块内存区域，几乎所有的对象实例在这里分配内存，也是垃圾收集器进行垃圾收集的最重要的内存区域。因此很多时候也叫GC堆
线程私有的分配缓存区(Thread Local Alloaction Buffer)也是在堆划分出来的

JDK8的版本，因使用元空间代替永久代，字符串常量池和类的静态变量也放入java堆中。

![image](https://user-images.githubusercontent.com/13992911/115152555-27ef3180-a0a4-11eb-8f50-ea6551a18beb.png)

### 2.5 元空间(MetaSpace)

主要存储类的元数据，比如类的各种描述信息，类名、方法、字段、访问限制等，既编译器编译后的代码等数据
运行时常量池：Class文件中除了有类的版本、字段、方法等描述等信息外；还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分将在类加载后存放到元空间的运行时常量池中

**使用元空间代替永久代原因**
* 永久代的大小是在启动时固定好的，很难进行调优；太大则容易导致永久代溢出；太小在运行时，容易抛出OutOfMemeryError
* 字符串存在永久代中，使用时易出问题，由于永久代内存经常不够用，爆出异常OutOfMemoryError: PermGen


### 直接内存

它并不是虚拟机运行时数据区的一般分，也不在规范定义。JDK1.4，引入了Channel(通道)与Buffer(缓存区)的I/O方式，它可以使用Native函数分配堆外内存，可通过DirectByteBuffer操作。
